/**
 * BeeWatch Firmware v0.7.0 - Production Release
 * 
 * CHANGES FROM v0.3.1:
 * - Added gain compensation (default 0.35) for mic calibration
 * - Added background sampling mode for rolling history
 * - Added confidence threshold option
 * - Improved debug output formatting
 * - Fixed filter state persistence
 * - Added 'g' command for gain adjustment
 * 
 * BUILD: cmake .. -DPICO_BOARD=pico2_w && make -j4
 */

#include <stdio.h>
#include <math.h>
#include <vector>
#include <string>
#include <cstring>
#include <numeric>

#include "pico/stdlib.h"
#include "hardware/adc.h"
#include "hardware/dma.h"
#include "hardware/i2c.h"
#include "hardware/watchdog.h"
#include "pico/cyw43_arch.h"

#include "lwip/pbuf.h"
#include "lwip/tcp.h"
#include "lwip/dns.h"
#include "lwip/init.h"

#include "flash_config.h"
#include "edge-impulse-sdk/classifier/ei_run_classifier.h"
#include "edge-impulse-sdk/dsp/numpy.hpp"

// =============================================================================
// CONFIGURATION
// =============================================================================

#define FIRMWARE_VERSION    "0.7.0"

// Audio
#define SAMPLE_RATE_HZ      16000
#define CAPTURE_SECONDS     6
#define AUDIO_BUFFER_SIZE   (SAMPLE_RATE_HZ * CAPTURE_SECONDS)
#define FFT_SIZE            512
#define FFT_HOP             512
#define NUM_FREQ_BINS       20

// ML
#define HISTORY_SIZE        12
#define CONFIDENCE_THRESHOLD 0.60f  // Only report Event if confidence > this

// Hardware pins
#define MIC_PIN             26
#define ADC_CHANNEL         0
#define SHT_ADDR            0x44
#define I2C_INST            i2c0
#define SHT_SDA_PIN         4
#define SHT_SCL_PIN         5

// Background sampling (optional)
#define BACKGROUND_SAMPLE_INTERVAL_MS  60000  // 1 minute
static bool g_background_sampling = false;
static uint32_t g_last_background_sample = 0;

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// =============================================================================
// GLOBALS
// =============================================================================

static uint16_t g_audio_buffer[AUDIO_BUFFER_SIZE];
static float g_fft_input[FFT_SIZE];
static float g_hanning_window[FFT_SIZE];
static float g_features_summer[20];
static float g_features_winter[5];
static double g_bin_accum[NUM_FREQ_BINS];
static std::vector<float> g_density_history;
static std::vector<float> g_temp_history;
static float g_last_temp = 0.0f;
static float g_last_hum = 0.0f;
static int g_dma_chan;
static dma_channel_config g_dma_cfg;

// Mock mode
static bool g_mock_mode = false;
static float g_mock_temp = 25.0f;
static float g_mock_hum = 50.0f;
static float g_mock_hour = 14.0f;

// --- GAIN COMPENSATION ---
// The TLC272CP op-amp provides ~22x gain, which produces larger ADC swings
// than the Mac's built-in microphone used for training.
// 
// Calibration (quiet room):
// - Mac bins[4-7]: ~0.02-0.05
// - Pico with gain=1.0: ~0.28-0.34  
// - Pico with gain=0.35: ~0.02-0.04 ✓
//
// Adjust with 'g' command (e.g., g0.35)
static float g_gain_compensation = 0.35f;

// Filter state (must persist across windows)
static float hp_w1 = 0, hp_w2 = 0;
static float lp1_w1 = 0;
static float lp2_w1 = 0, lp2_w2 = 0;

// Pre-computed twiddle factors for DFT
static float g_cos_table[NUM_FREQ_BINS][FFT_SIZE];
static float g_sin_table[NUM_FREQ_BINS][FFT_SIZE];

// Filter coefficients (Butterworth, generated by scipy.signal.butter)
// HP: 2nd order @ 100Hz
static const float HP_B0 = 0.9726139f;
static const float HP_B1 = -1.9452278f;
static const float HP_B2 = 0.9726139f;
static const float HP_A1 = -1.9444777f;
static const float HP_A2 = 0.9459779f;

// LP: 3rd order @ 6kHz (2 cascaded biquads)
static const float LP1_B0 = 0.4459029f;
static const float LP1_B1 = 0.4459029f;
static const float LP1_B2 = 0.0f;
static const float LP1_A1 = 0.4142136f;
static const float LP1_A2 = 0.0f;

static const float LP2_B0 = 0.3913f;
static const float LP2_B1 = 0.7827f;
static const float LP2_B2 = 0.3913f;
static const float LP2_A1 = -0.3695f;
static const float LP2_A2 = -0.1958f;

// =============================================================================
// NETWORK GLOBALS
// =============================================================================

#define HTTP_BUF_SIZE 4096
static char http_rx_buffer[HTTP_BUF_SIZE];
static int http_rx_index = 0;
static bool http_complete = false;
static bool wifi_connected = false;
static uint32_t last_sync_time = 0;
#define SYNC_INTERVAL_MS 2000

struct Command {
    std::string type;
    std::string params;
    bool from_network;
};
static std::vector<Command> cmd_queue;

// =============================================================================
// FORWARD DECLARATIONS
// =============================================================================

static void led_set(bool on);
void process_command(Command cmd);
static bool read_climate();
static void capture_audio();
static float process_and_compute_features();
static void run_summer_inference(float density);
static void run_winter_inference(float density);
static void stream_audio(int seconds);
static void debug_features();
static void show_help();

// =============================================================================
// DSP FUNCTIONS
// =============================================================================

static void reset_filters() {
    hp_w1 = hp_w2 = 0;
    lp1_w1 = 0;
    lp2_w1 = lp2_w2 = 0;
}

static inline float biquad_hp(float x) {
    float y = HP_B0 * x + hp_w1;
    hp_w1 = HP_B1 * x - HP_A1 * y + hp_w2;
    hp_w2 = HP_B2 * x - HP_A2 * y;
    return y;
}

static inline float biquad_lp1(float x) {
    float y = LP1_B0 * x + lp1_w1;
    lp1_w1 = LP1_B1 * x - LP1_A1 * y;
    return y;
}

static inline float biquad_lp2(float x) {
    float y = LP2_B0 * x + lp2_w1;
    lp2_w1 = LP2_B1 * x - LP2_A1 * y + lp2_w2;
    lp2_w2 = LP2_B2 * x - LP2_A2 * y;
    return y;
}

static float compute_bin_magnitude_accurate(const float* windowed_data, int k) {
    double real_sum = 0.0, imag_sum = 0.0;
    for (int n = 0; n < FFT_SIZE; n++) {
        real_sum += windowed_data[n] * g_cos_table[k][n];
        imag_sum += windowed_data[n] * g_sin_table[k][n];
    }
    return (float)sqrt(real_sum * real_sum + imag_sum * imag_sum);
}

// =============================================================================
// NETWORK (HTTP Client)
// =============================================================================

static err_t http_recv_callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err) {
    if (!p) {
        tcp_close(tpcb);
        http_complete = true;
        return ERR_OK;
    }
    
    if (http_rx_index < HTTP_BUF_SIZE - 1) {
        int copy_len = p->len;
        if (http_rx_index + copy_len >= HTTP_BUF_SIZE) {
            copy_len = HTTP_BUF_SIZE - 1 - http_rx_index;
        }
        memcpy(&http_rx_buffer[http_rx_index], p->payload, copy_len);
        http_rx_index += copy_len;
        http_rx_buffer[http_rx_index] = 0;
    }
    
    tcp_recved(tpcb, p->tot_len);
    pbuf_free(p);
    return ERR_OK;
}

static err_t http_connected_callback(void *arg, struct tcp_pcb *tpcb, err_t err) {
    if (err != ERR_OK) return err;
    const char* request = (const char*)arg;
    tcp_write(tpcb, request, strlen(request), TCP_WRITE_FLAG_COPY);
    tcp_output(tpcb);
    return ERR_OK;
}

static void http_error_callback(void *arg, err_t err) {
    printf("[NET] TCP Error: %d\n", err);
    http_complete = true;
}

static bool perform_http_request(const char* method, const char* path, const char* body) {
    if (!wifi_connected) return false;

    http_rx_index = 0;
    http_rx_buffer[0] = 0;
    http_complete = false;

    struct tcp_pcb *pcb = tcp_new();
    if (!pcb) return false;

    tcp_err(pcb, http_error_callback);

    ip_addr_t server_ip;
    ip4addr_aton(sys_config.server_ip, &server_ip);

    char request[1024];
    int len = snprintf(request, sizeof(request), 
        "%s /api/v1/%s HTTP/1.1\r\n"
        "Host: %s:%d\r\n"
        "Connection: close\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %d\r\n"
        "\r\n"
        "%s", 
        method, path, sys_config.server_ip, sys_config.server_port, 
        (int)strlen(body), body);

    tcp_arg(pcb, (void*)request);
    tcp_recv(pcb, http_recv_callback);
    
    if (tcp_connect(pcb, &server_ip, sys_config.server_port, http_connected_callback) != ERR_OK) {
        printf("[NET] Connection failed\n");
        return false;
    }

    uint32_t start = to_ms_since_boot(get_absolute_time());
    while (!http_complete) {
        cyw43_arch_poll();
        sleep_ms(5);
        if (to_ms_since_boot(get_absolute_time()) - start > 3000) {
            tcp_abort(pcb);
            if (http_rx_index > 0) return true;
            printf("[NET] Timeout\n");
            return false;
        }
    }
    return true;
}

static void log_to_server(const char* msg) {
    if (!wifi_connected) return;
    char json[256];
    snprintf(json, sizeof(json), 
        "{\"node_id\": \"%s\", \"message\": \"%s\"}", 
        sys_config.node_id, msg);
    perform_http_request("POST", "logs/", json);
}

static void parse_server_commands() {
    char* body = strstr(http_rx_buffer, "\r\n\r\n");
    if (!body) return;
    body += 4;

    if (strstr(body, "RUN_INFERENCE")) {
        std::string params = strstr(body, "winter") ? "winter" : "summer";
        cmd_queue.push_back({"RUN_INFERENCE", params, true});
        printf("[NET] CMD: RUN_INFERENCE (%s)\n", params.c_str());
    }
    else if (strstr(body, "READ_CLIMATE")) {
        cmd_queue.push_back({"READ_CLIMATE", "", true});
        printf("[NET] CMD: READ_CLIMATE\n");
    }
    else if (strstr(body, "PING")) {
        cmd_queue.push_back({"PING", "", true});
    }
}

// =============================================================================
// HARDWARE SETUP
// =============================================================================

static void led_set(bool on) {
    cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, on);
}

static void setup_hardware() {
    stdio_init_all();
    load_config();

    printf("\n");
    printf("╔══════════════════════════════════════════╗\n");
    printf("║     BEEWATCH FIRMWARE v%s            ║\n", FIRMWARE_VERSION);
    printf("║     Node: %-30s ║\n", sys_config.node_id);
    printf("╚══════════════════════════════════════════╝\n\n");

    if (cyw43_arch_init()) {
        printf("[ERR] WiFi init failed\n");
        return;
    }
    cyw43_arch_enable_sta_mode();

    if (strlen(sys_config.wifi_ssid) > 0) {
        printf("[NET] Connecting to %s...\n", sys_config.wifi_ssid);
        int retries = 3;
        while (retries > 0 && !wifi_connected) {
            led_set(true);
            int err = cyw43_arch_wifi_connect_timeout_ms(
                sys_config.wifi_ssid, sys_config.wifi_pass, 
                CYW43_AUTH_WPA2_AES_PSK, 15000);
            led_set(false);
            if (err == 0) {
                printf("[NET] Connected! IP: %s\n", 
                    ip4addr_ntoa(netif_ip4_addr(netif_list)));
                wifi_connected = true;
            } else {
                printf("[NET] WiFi Failed (%d). Retrying...\n", err);
                sleep_ms(2000);
                retries--;
            }
        }
    }

    // I2C for SHT20
    i2c_init(I2C_INST, 100 * 1000);
    gpio_set_function(SHT_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(SHT_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(SHT_SDA_PIN);
    gpio_pull_up(SHT_SCL_PIN);

    // ADC for microphone
    adc_init();
    adc_gpio_init(MIC_PIN);
    adc_select_input(ADC_CHANNEL);

    // DMA for audio capture
    g_dma_chan = dma_claim_unused_channel(true);
    g_dma_cfg = dma_channel_get_default_config(g_dma_chan);
    channel_config_set_transfer_data_size(&g_dma_cfg, DMA_SIZE_16);
    channel_config_set_read_increment(&g_dma_cfg, false);
    channel_config_set_write_increment(&g_dma_cfg, true);
    channel_config_set_dreq(&g_dma_cfg, DREQ_ADC);

    // Pre-compute Hanning window
    for (int i = 0; i < FFT_SIZE; i++) {
        g_hanning_window[i] = 0.5f * (1.0f - cosf(2.0f * (float)M_PI * (float)i / (float)(FFT_SIZE - 1)));
    }

    // Pre-compute DFT twiddle factors
    for (int k = 0; k < NUM_FREQ_BINS; k++) {
        for (int n = 0; n < FFT_SIZE; n++) {
            double angle = -2.0 * M_PI * k * n / FFT_SIZE;
            g_cos_table[k][n] = (float)cos(angle);
            g_sin_table[k][n] = (float)sin(angle);
        }
    }

    printf("[INIT] Hardware ready. Gain: %.2f\n", g_gain_compensation);
    if (wifi_connected) log_to_server("System Booted v" FIRMWARE_VERSION);
}

// =============================================================================
// SENSORS
// =============================================================================

static bool read_climate() {
    if (g_mock_mode) {
        g_last_temp = g_mock_temp;
        g_last_hum = g_mock_hum;
        printf("[SENSOR] MOCK MODE: Temp=%.2f C, Humidity=%.2f %%\n", 
            g_last_temp, g_last_hum);
        return true;
    }

    uint8_t cmd[2] = {0x24, 0x00};
    i2c_write_blocking(I2C_INST, SHT_ADDR, cmd, 2, false);
    sleep_ms(15);

    uint8_t data[6];
    if (i2c_read_blocking(I2C_INST, SHT_ADDR, data, 6, false) == PICO_ERROR_GENERIC) {
        printf("[SENSOR] Read failed\n");
        return false;
    }

    uint16_t t_raw = (data[0] << 8) | data[1];
    uint16_t h_raw = (data[3] << 8) | data[4];
    g_last_temp = -45.0f + (175.0f * (float)t_raw / 65535.0f);
    g_last_hum = 100.0f * ((float)h_raw / 65535.0f);

    printf("[SENSOR] Temp: %.2f C, Humidity: %.2f %%\n", g_last_temp, g_last_hum);
    return true;
}

// =============================================================================
// AUDIO CAPTURE
// =============================================================================

static void capture_audio() {
    printf("\n[REC] Capturing %d samples (%.1f seconds)...\n", 
        AUDIO_BUFFER_SIZE, (float)CAPTURE_SECONDS);

    led_set(true);
    adc_fifo_drain();
    adc_fifo_setup(true, true, 1, false, false);
    adc_set_clkdiv(3000.0f - 1.0f);  // 48MHz / 3000 = 16kHz
    
    dma_channel_configure(g_dma_chan, &g_dma_cfg, 
        g_audio_buffer, &adc_hw->fifo, AUDIO_BUFFER_SIZE, true);
    
    adc_run(true);
    dma_channel_wait_for_finish_blocking(g_dma_chan);
    adc_run(false);
    led_set(false);

    // Stats
    uint32_t min_val = 4095, max_val = 0;
    uint64_t sum = 0;
    for (int i = 0; i < AUDIO_BUFFER_SIZE; i++) {
        if (g_audio_buffer[i] < min_val) min_val = g_audio_buffer[i];
        if (g_audio_buffer[i] > max_val) max_val = g_audio_buffer[i];
        sum += g_audio_buffer[i];
    }
    float mean = (float)sum / AUDIO_BUFFER_SIZE;

    printf("[REC] Complete. Min=%lu, Max=%lu, Mean=%.1f\n", min_val, max_val, mean);
}

static void stream_audio(int seconds) {
    if (seconds <= 0 || seconds > 6) seconds = 6;
    int samples = seconds * SAMPLE_RATE_HZ;

    printf("[STREAM] Capturing %d samples...\n", samples);
    led_set(true);
    
    adc_fifo_drain();
    adc_fifo_setup(true, true, 1, false, false);
    adc_set_clkdiv(3000.0f - 1.0f);
    
    dma_channel_configure(g_dma_chan, &g_dma_cfg, 
        g_audio_buffer, &adc_hw->fifo, samples, true);
    
    adc_run(true);
    dma_channel_wait_for_finish_blocking(g_dma_chan);
    adc_run(false);
    led_set(false);

    // Compute stats
    uint64_t sum = 0;
    for (int i = 0; i < samples; i++) sum += g_audio_buffer[i];
    float mean = (float)sum / samples;
    
    uint64_t var_sum = 0;
    for (int i = 0; i < samples; i++) {
        float diff = g_audio_buffer[i] - mean;
        var_sum += (uint64_t)(diff * diff);
    }
    float std_dev = sqrtf((float)var_sum / samples);

    uint32_t min_val = 4095, max_val = 0;
    for (int i = 0; i < samples; i++) {
        if (g_audio_buffer[i] < min_val) min_val = g_audio_buffer[i];
        if (g_audio_buffer[i] > max_val) max_val = g_audio_buffer[i];
    }

    printf("[STREAM] Stats: Min=%lu, Max=%lu, StdDev=%.1f\n", min_val, max_val, std_dev);
    printf("HDR:%u:%u:%.1f\n", samples * 2, samples, std_dev);
    stdio_flush();
    sleep_ms(10);

    // Send raw bytes
    for (int i = 0; i < samples; i++) {
        putchar_raw(g_audio_buffer[i] & 0xFF);
        putchar_raw((g_audio_buffer[i] >> 8) & 0xFF);
    }
    stdio_flush();
    sleep_ms(10);
    printf("\nEND\n");
}

// =============================================================================
// DSP PROCESSING
// =============================================================================

static float process_and_compute_features() {
    printf("[DSP] Processing audio...\n");

    // Reset accumulators
    for (int k = 0; k < NUM_FREQ_BINS; k++) {
        g_bin_accum[k] = 0.0;
    }

    // Compute DC offset
    double dc_sum = 0;
    for (int i = 0; i < AUDIO_BUFFER_SIZE; i++) {
        dc_sum += g_audio_buffer[i];
    }
    float dc_offset = (float)(dc_sum / AUDIO_BUFFER_SIZE);

    printf("[DSP] DC offset: %.1f (gain compensation: %.2f)\n", 
        dc_offset, g_gain_compensation);

    int num_windows = (AUDIO_BUFFER_SIZE - FFT_SIZE) / FFT_HOP + 1;
    printf("[DSP] Windows: %d\n", num_windows);

    // Reset filter state for consistent results
    reset_filters();

    double rms_sum = 0;
    int rms_count = 0;

    for (int w = 0; w < num_windows; w++) {
        int offset = w * FFT_HOP;

        for (int i = 0; i < FFT_SIZE; i++) {
            // Normalize ADC to ~[-1, 1] range
            float sample = ((float)g_audio_buffer[offset + i] - dc_offset) / 2048.0f;
            
            // Apply gain compensation
            sample *= g_gain_compensation;

            // Apply filters: HP -> LP1 -> LP2
            sample = biquad_lp2(biquad_lp1(biquad_hp(sample)));

            // Accumulate for RMS
            rms_sum += sample * sample;
            rms_count++;

            // Apply window for FFT
            g_fft_input[i] = sample * g_hanning_window[i];
        }

        // Compute DFT for each frequency bin
        for (int k = 0; k < NUM_FREQ_BINS; k++) {
            g_bin_accum[k] += compute_bin_magnitude_accurate(g_fft_input, k);
        }
    }

    // Compute RMS density
    float density = sqrtf((float)(rms_sum / rms_count));

    // Average FFT bins across windows
    for (int k = 0; k < NUM_FREQ_BINS; k++) {
        g_bin_accum[k] /= num_windows;
    }

    printf("[DSP] RMS density: %.6f\n", density);
    printf("[DSP] Bins[4-7]: %.6f, %.6f, %.6f, %.6f\n",
        g_bin_accum[4], g_bin_accum[5], g_bin_accum[6], g_bin_accum[7]);

    return density;
}

// =============================================================================
// ML INFERENCE
// =============================================================================

static void run_summer_inference(float current_density) {
    // Update rolling history
    if (g_density_history.size() >= HISTORY_SIZE) {
        g_density_history.erase(g_density_history.begin());
    }
    g_density_history.push_back(current_density);

    // Compute rolling average
    float rolling = 0;
    for (float d : g_density_history) rolling += d;
    rolling = (g_density_history.size() > 0) ? 
        rolling / g_density_history.size() : current_density;

    // Compute spike ratio
    float spike = current_density / (rolling + 1e-6f);

    printf("[AI] Building feature vector...\n");

    // Build feature vector
    g_features_summer[0] = g_last_temp;
    g_features_summer[1] = g_last_hum;
    g_features_summer[2] = g_mock_mode ? g_mock_hour : 14.0f;
    g_features_summer[3] = spike;
    
    for (int i = 0; i < 16; i++) {
        g_features_summer[4 + i] = (float)g_bin_accum[4 + i];
    }

    printf("[AI] Features: temp=%.1f, hum=%.1f, hour=%.1f, spike=%.3f\n",
        g_features_summer[0], g_features_summer[1], 
        g_features_summer[2], g_features_summer[3]);
    printf("[AI] FFT[4-7]: %.6f, %.6f, %.6f, %.6f\n",
        g_features_summer[4], g_features_summer[5],
        g_features_summer[6], g_features_summer[7]);

    // Run Edge Impulse inference
    signal_t signal;
    numpy::signal_from_buffer(g_features_summer, 20, &signal);
    
    ei_impulse_result_t result = {0};
    EI_IMPULSE_ERROR err = run_classifier(&signal, &result, false);

    if (err != EI_IMPULSE_OK) {
        printf("[AI] Inference error: %d\n", err);
        return;
    }

    // Find best class
    const char* label = "Unknown";
    float score = 0.0f;
    int best_idx = 0;
    
    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
        if (result.classification[ix].value > score) {
            score = result.classification[ix].value;
            label = result.classification[ix].label;
            best_idx = ix;
        }
    }

    // Determine final status with threshold
    const char* status;
    const char* status_icon;
    
    if (best_idx == 0 || score < CONFIDENCE_THRESHOLD) {
        // Normal, or not confident enough about Event
        status = "NORMAL STATE";
        status_icon = "[OK]";
    } else {
        status = "SWARMING / PIPING";
        status_icon = "[!!]";
    }

    // Output results
    printf("\n==================== HIVE STATUS ====================\n");
    printf("State:          %s %s\n", status_icon, status);
    printf("Confidence:     %.1f%%\n", score * 100);
    printf("Activity(Spike):%.2f\n", spike);
    if (g_mock_mode) {
        printf("Mode:           MOCK (temp=%.1f, hum=%.1f)\n", g_mock_temp, g_mock_hum);
    }
    printf("-----------------------------------------------------\n");
    printf("Raw Probs:      [Normal: %.3f, Event: %.3f]\n",
        result.classification[0].value, result.classification[1].value);
    printf("=====================================================\n");

    // JSON output for parsing
    printf("JSON_OUT:{\"status\":\"%s\",\"conf\":%.3f,\"spike\":%.3f,\"mock\":%s}\n",
        status, score, spike, g_mock_mode ? "true" : "false");

    // Upload to server
    if (wifi_connected) {
        char json[256];
        snprintf(json, sizeof(json),
            "{\"node_id\": \"%s\", \"model_type\": \"summer\", "
            "\"classification\": \"%s\", \"confidence\": %.2f, "
            "\"timestamp\": \"2025-01-01T00:00:00\"}",
            sys_config.node_id, status, score);
        perform_http_request("POST", "inference/", json);
    }
}

static void run_winter_inference(float density) {
    printf("[AI] Winter model not yet implemented\n");
    if (wifi_connected) log_to_server("Winter inference requested");
}

// =============================================================================
// DEBUG
// =============================================================================

static void debug_features() {
    printf("\n[DEBUG] Full feature dump:\n");
    
    read_climate();
    capture_audio();
    float density = process_and_compute_features();

    // Compute spike for display
    float rolling = 0;
    if (g_density_history.size() > 0) {
        for (float d : g_density_history) rolling += d;
        rolling /= g_density_history.size();
    } else {
        rolling = density;
    }
    float spike = density / (rolling + 1e-6f);

    printf("\n--- FEATURE VECTOR (20 elements) ---\n");
    printf("MODE: %s\n", g_mock_mode ? "MOCK" : "REAL SENSOR");
    printf("f[0] temp:       %.4f\n", g_last_temp);
    printf("f[1] humidity:   %.4f\n", g_last_hum);
    printf("f[2] hour:       %.4f\n", g_mock_mode ? g_mock_hour : 14.0f);
    printf("f[3] spike:      %.4f (density=%.6f)\n", spike, density);
    
    const char* freq_labels[] = {
        "hz_125", "hz_156", "hz_188", "hz_219", "hz_250", "hz_281",
        "hz_312", "hz_344", "hz_375", "hz_406", "hz_438", "hz_469",
        "hz_500", "hz_531", "hz_562", "hz_594"
    };
    
    for (int i = 0; i < 16; i++) {
        printf("f[%d] %s:   %.6f\n", i + 4, freq_labels[i], g_bin_accum[4 + i]);
    }
    printf("-----------------------------------\n");
}

static void show_help() {
    printf("\n");
    printf("╔═══════════════════════════════════════════════════════╗\n");
    printf("║                    BEEWATCH COMMANDS                  ║\n");
    printf("╠═══════════════════════════════════════════════════════╣\n");
    printf("║  s        - Run Summer model inference                ║\n");
    printf("║  w        - Run Winter model inference                ║\n");
    printf("║  t        - Read temperature/humidity                 ║\n");
    printf("║  a[N]     - Stream N seconds of audio (default 6)     ║\n");
    printf("║  d        - Debug dump (show all features)            ║\n");
    printf("║  m        - Toggle mock sensor mode                   ║\n");
    printf("║  c        - Clear rolling history                     ║\n");
    printf("║  g[N.NN]  - Show/set gain compensation (e.g. g0.35)   ║\n");
    printf("║  b        - Toggle background sampling                ║\n");
    printf("║  p        - Ping (show version & status)              ║\n");
    printf("║  v T H HR - Set mock values (temp, hum, hour)         ║\n");
    printf("║  wifi S P - Set WiFi SSID and password                ║\n");
    printf("║  server I - Set server IP address                     ║\n");
    printf("║  h        - Show this help                            ║\n");
    printf("╚═══════════════════════════════════════════════════════╝\n");
    printf("\n");
}

// =============================================================================
// COMMAND PROCESSOR
// =============================================================================

void process_command(Command cmd) {
    if (cmd.type == "READ_CLIMATE") {
        read_climate();
        if (cmd.from_network && wifi_connected) {
            char json[128];
            snprintf(json, sizeof(json),
                "{\"node_id\":\"%s\",\"temperature_c\":%.2f,"
                "\"humidity_pct\":%.2f,\"battery_mv\":4200}",
                sys_config.node_id, g_last_temp, g_last_hum);
            perform_http_request("POST", "telemetry/", json);
        }
    }
    else if (cmd.type == "RUN_INFERENCE") {
        read_climate();
        capture_audio();
        float density = process_and_compute_features();
        
        if (cmd.params == "winter") {
            run_winter_inference(density);
        } else {
            run_summer_inference(density);
        }
    }
    else if (cmd.type == "CAPTURE_AUDIO") {
        int seconds = cmd.params.empty() ? 6 : atoi(cmd.params.c_str());
        stream_audio(seconds);
    }
    else if (cmd.type == "TOGGLE_MOCK") {
        g_mock_mode = !g_mock_mode;
        printf("[CONFIG] Mock mode %s\n", g_mock_mode ? "ENABLED" : "DISABLED");
        if (g_mock_mode) {
            printf("  Temp: %.1f C, Humidity: %.1f %%, Hour: %.1f\n",
                g_mock_temp, g_mock_hum, g_mock_hour);
            printf("  (Matches mac_shim.py defaults for parity testing)\n");
        }
        if (wifi_connected) {
            log_to_server(g_mock_mode ? "Mock Enabled" : "Mock Disabled");
        }
    }
    else if (cmd.type == "CLEAR_HISTORY") {
        g_density_history.clear();
        g_temp_history.clear();
        reset_filters();
        printf("[CONFIG] History cleared. Ready for fresh parity test.\n");
    }
    else if (cmd.type == "DEBUG_DUMP") {
        debug_features();
    }
    else if (cmd.type == "PING") {
        printf("\n[PING] BeeWatch Firmware v%s\n", FIRMWARE_VERSION);
        printf("  Node ID: %s\n", sys_config.node_id);
        printf("  WiFi: %s\n", wifi_connected ? "Connected" : "Disconnected");
        printf("  Mock Mode: %s\n", g_mock_mode ? "ON" : "OFF");
        printf("  Gain: %.2f\n", g_gain_compensation);
        printf("  History: %zu samples\n", g_density_history.size());
        printf("  Background Sampling: %s\n", g_background_sampling ? "ON" : "OFF");
        if (wifi_connected) log_to_server("PONG");
    }
    else if (cmd.type == "SHOW_GAIN") {
        printf("[CONFIG] Current gain compensation: %.3f\n", g_gain_compensation);
    }
    else if (cmd.type == "SET_GAIN") {
        float new_gain = atof(cmd.params.c_str());
        if (new_gain > 0.01f && new_gain < 10.0f) {
            g_gain_compensation = new_gain;
            printf("[CONFIG] Gain compensation set to: %.3f\n", g_gain_compensation);
        } else {
            printf("[CONFIG] Invalid gain value. Use 0.01-10.0\n");
        }
    }
    else if (cmd.type == "TOGGLE_BACKGROUND") {
        g_background_sampling = !g_background_sampling;
        printf("[CONFIG] Background sampling %s\n", 
            g_background_sampling ? "ENABLED" : "DISABLED");
        if (g_background_sampling) {
            printf("  Interval: %d ms\n", BACKGROUND_SAMPLE_INTERVAL_MS);
        }
    }
    else if (cmd.type == "HELP") {
        show_help();
    }
}

// =============================================================================
// MAIN LOOP
// =============================================================================

int main() {
    setup_hardware();
    
    char serial_buf[64];
    int serial_ptr = 0;

    printf("\n>>> BeeWatch Node Ready. Type 'h' for help.\n> ");

    while (true) {
        // 1. Handle serial input
        int c = getchar_timeout_us(0);
        if (c != PICO_ERROR_TIMEOUT) {
            if (c == '\n' || c == '\r') {
                serial_buf[serial_ptr] = 0;
                printf("\n");

                // Parse command
                if (serial_ptr > 0) {
                    char cmd_char = serial_buf[0];
                    char* param = serial_ptr > 1 ? &serial_buf[1] : nullptr;

                    switch (cmd_char) {
                        case 's':
                            cmd_queue.push_back({"RUN_INFERENCE", "summer", false});
                            break;
                        case 'w':
                            cmd_queue.push_back({"RUN_INFERENCE", "winter", false});
                            break;
                        case 't':
                            cmd_queue.push_back({"READ_CLIMATE", "", false});
                            break;
                        case 'a':
                            cmd_queue.push_back({"CAPTURE_AUDIO", param ? param : "6", false});
                            break;
                        case 'd':
                            cmd_queue.push_back({"DEBUG_DUMP", "", false});
                            break;
                        case 'm':
                            cmd_queue.push_back({"TOGGLE_MOCK", "", false});
                            break;
                        case 'c':
                            cmd_queue.push_back({"CLEAR_HISTORY", "", false});
                            break;
                        case 'p':
                            cmd_queue.push_back({"PING", "", false});
                            break;
                        case 'h':
                        case '?':
                            cmd_queue.push_back({"HELP", "", false});
                            break;
                        case 'b':
                            cmd_queue.push_back({"TOGGLE_BACKGROUND", "", false});
                            break;
                        case 'g':
                            if (param && strlen(param) > 0) {
                                cmd_queue.push_back({"SET_GAIN", param, false});
                            } else {
                                cmd_queue.push_back({"SHOW_GAIN", "", false});
                            }
                            break;
                        case 'v':
                            if (param) {
                                float t, h, hr;
                                if (sscanf(param, "%f,%f,%f", &t, &h, &hr) == 3 ||
                                    sscanf(param, "%f %f %f", &t, &h, &hr) == 3) {
                                    g_mock_temp = t;
                                    g_mock_hum = h;
                                    g_mock_hour = hr;
                                    printf("[CONFIG] Mock values set: T=%.1f, H=%.1f, Hr=%.1f\n",
                                        t, h, hr);
                                }
                            }
                            break;
                        default:
                            // Check for multi-word commands
                            if (strncmp(serial_buf, "wifi ", 5) == 0) {
                                char ssid[32], pass[64];
                                if (sscanf(serial_buf + 5, "%31s %63s", ssid, pass) == 2) {
                                    strncpy(sys_config.wifi_ssid, ssid, 31);
                                    strncpy(sys_config.wifi_pass, pass, 63);
                                    save_config();
                                    printf("[CONFIG] WiFi credentials saved. Reboot to connect.\n");
                                }
                            }
                            else if (strncmp(serial_buf, "server ", 7) == 0) {
                                char ip[16];
                                if (sscanf(serial_buf + 7, "%15s", ip) == 1) {
                                    strncpy(sys_config.server_ip, ip, 15);
                                    save_config();
                                    printf("[CONFIG] Server IP saved: %s\n", ip);
                                }
                            }
                            else {
                                printf("[ERR] Unknown command: '%s'. Type 'h' for help.\n", serial_buf);
                            }
                            break;
                    }
                }

                serial_ptr = 0;
                printf("> ");
            }
            else if (serial_ptr < 63) {
                putchar(c);
                serial_buf[serial_ptr++] = (char)c;
            }
        }

        // 2. Poll network for commands
        if (wifi_connected) {
            uint32_t now = to_ms_since_boot(get_absolute_time());
            if (now - last_sync_time > SYNC_INTERVAL_MS) {
                last_sync_time = now;
                char query[128];
                snprintf(query, 128, "commands/pending?node_id=%s", sys_config.node_id);
                if (perform_http_request("GET", query, "")) {
                    parse_server_commands();
                }
            }
        }

        // 3. Background sampling (if enabled)
        if (g_background_sampling) {
            uint32_t now = to_ms_since_boot(get_absolute_time());
            if (now - g_last_background_sample > BACKGROUND_SAMPLE_INTERVAL_MS) {
                g_last_background_sample = now;
                printf("\n[BACKGROUND] Auto-sampling...\n");
                
                read_climate();
                capture_audio();
                float density = process_and_compute_features();
                
                // Just update history, don't run full inference
                if (g_density_history.size() >= HISTORY_SIZE) {
                    g_density_history.erase(g_density_history.begin());
                }
                g_density_history.push_back(density);
                
                printf("[BACKGROUND] History: %zu samples, latest density: %.6f\n",
                    g_density_history.size(), density);
                printf("> ");
            }
        }

        // 4. Execute command queue
        if (!cmd_queue.empty()) {
            Command cmd = cmd_queue.front();
            cmd_queue.erase(cmd_queue.begin());
            process_command(cmd);
            printf("> ");
        }

        cyw43_arch_poll();
        sleep_ms(10);
    }

    return 0;
}
